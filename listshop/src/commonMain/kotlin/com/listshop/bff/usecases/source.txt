        func makeSignInUseCase(userName: String,
                               password: String,
                               onStart: @escaping () -> Void,
                               onComplete: @escaping (OnboardingTagTreeUseCaseResult) -> Void) -> UseCase {
            let useCase = SignInUseCase(userName: userName,
                    password: password,
                    userService: userService,
                    sessionService: sessionService,
                    listService: listService,
                    syncService: syncService,
                    onStart: onStart,
                    onComplete: onComplete)
            return useCase
        }


//
//  SignInUseCase.swift
//  SeedBeta
//
//  Created by Margaret Martin on 6/15/19.
//  Copyright Â© 2019 Margaret Martin. All rights reserved.
//

import Foundation
import PromiseKit

public class SignInUseCase: UseCase {

    typealias OnboardingUseCaseResult = Swift.Result<(TransitionViewState, TagTree), ListShopError>

    let userService: UserService
    let sessionService: UserSessionService
    let listService: ListService
    let syncService: SyncService
    let onComplete: (OnboardingUseCaseResult) -> Void
    let onStart: () -> Void
    let userName: String
    let userPassword: String

    init(userName: String,
         password: String,
         userService: UserService,
         sessionService: UserSessionService,
         listService: ListService,
         syncService: SyncService,
         onStart: (() -> Void)?,
         onComplete: ((OnboardingUseCaseResult) -> Void)?) {
        self.userName = userName
        userPassword = password
        self.userService = userService
        self.listService = listService
        self.sessionService = sessionService
        self.syncService = syncService
        self.onStart = onStart ?? {
        }
        self.onComplete = onComplete ?? { result in
        }
    }

    public func start() {
        onStart()

        // call signIn in UserService, which returns a token
        firstly(execute: {
            try userService.signInUser(userName: userName, password: userPassword)
        })
                .then({ [weak self] () -> Promise<Bool> in
                    self?.syncService.hasLocalList() ?? Promise.value(false)
                })
                .then { hasLocal -> Promise<(Bool, TagTree)> in
                    return try self.syncService.syncLookupData(connectionStatus: .connected).map {
                        (hasLocal, $0)
                    }
                }
                .then { (hasLocal, tagTree) -> Promise<(ShoppingList, TagTree)> in
                    //MM note - the handleLocalListOnLogin is buggy, and keeping the user
                    // from logging in, if their current list has been deleted on the server
                    /*
                     if (hasLocal) {
                        return self.syncService.handleLocalListOnLogin()
                    } else {
                        return self.listService.retrieveMostRecentList()
                    }
                     */
                    self.listService.retrieveMostRecentList().map {
                        ($0, tagTree)
                    }
                }
                .done({ (shoppingList, tagTree) in
                    self.goToListScreen(with: shoppingList, and: tagTree)
                })
                .done { [weak self] in
                    let _ = try? self?.syncService.syncStatistics(connectionStatus: .connected)
                }
                .catch { error in
                    if let lse = error as? ListShopError {
                        if (lse.title == "POSTINGDATA") {
                            // this is a merge list problem
                            let lse = ListShopError.mergeError
                            self.onComplete(.failure(lse))
                        } else {
                            // this is a sign-in / credentials problem
                            let lse = ListShopError.signInError
                            self.onComplete(.failure(lse))
                        }

                        print("Error signing in: \(lse.title) \(lse)")
                    } else {
                        let lse = ListShopError.signInError
                        self.onComplete(.failure(lse))
                    }
                }

    }

    private func goToListScreen(with shoppingList: ShoppingList, and tagTree: TagTree) -> () {
        firstly { () -> Promise<[ShoppingList]> in
            // make sure to finish syncing local data first before moving to local list
            try listService.retrieveListOfLists()
        }
                .done { listOfLists in
                    self.onComplete(.success((TransitionViewState.listScreen(shoppingList, listOfLists), tagTree)))
                }
                .catch { error in
                    print("Error: \(error) while syncing local list")
                    let lse = ListShopError(type: .core, title: "Can't get the lookup data", message: "Error while retrieving lookup data")
                    self.onComplete(.failure(lse))
                }
    }
}
